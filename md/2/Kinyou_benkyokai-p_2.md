# Kinyou_benkyokai-p 2

プログラミング的な内容(基礎編)

---

## プログラミングとは

プログラムを書いてコンピューターに処理をさせること

プログラムとは

→ コンピューターに対する命令

---

## 良いプログラム

コンピューターはプログラム通りにしか動かない

良いプログラムを書かなければコンピューターは望んだ動作をしない

---

## 良いプログラムを書くためには

頭が良くないとすぐに良いプログラムを思いつけない

→　アルゴリズムを学ぼう

---

## アルゴリズムとは

> アルゴリズム（英: algorithm [ˈælgəˌrɪðəm]）とは、数学、コンピューティング、言語学、あるいは関連する分野において、問題を解くための手順を定式化した形で表現したものを言う。「算法」と訳されることもある。

> 記録に残る最古のアルゴリズムは、エウクレイデスの原論のものである。その中でも、二つの整数の最大公約数を求めるユークリッドの互除法は、典型的なアルゴリズムとして知られている。

---


よくわかんないけど、とりあえずやってみよう

→　競技プログラミング

- 言語はなんでも良い
- C/C++が早い

---

# 基礎編

---

## GCD & LCM

> 正の整数 a,b を入力し、a と b の最大公約数と最小公倍数を出力するプログラムを作成して下さい。 (AOJ 0005 GCD and LCM)

```
a = 24 ,b = 16

→ gcd  = 8
→ lcm  = 48
```

---

## GCD(Greatest Common Divisor)

GCD(最大公約数)

[ユークリッドの互除法](https://en.wikipedia.org/wiki/Euclidean_algorithm)

1. 入力を m, n (m ≧ n) とする。
2. n = 0 なら、 m を出力してアルゴリズムを終了する。
3. m を n で割った余りを新たに n とし、更に 元のnを新たにm とし 2. に戻る。

```
gcd = (m,n) => { return n == 0 ? m : gcd(n ,(m % n)) }
```

TODO:c++で書いてみる

---


## LCM(Least Common Multiple)

LCM(最小公倍数)

```
lcm = (m,n) => {return (m*n)/ gcd(m,n) }
```

1. 入力値をm,nとする。
2. m * nを最小公約数(gcd(m,n))で割る

TODO:c++で書いてみる

---



## フィボナッチ数

> n番目のフィボナッチ数を出力せよ

```
n = 10
→　55

```

---

```
int fib(int n){
	return n <= 1 ? n : fib(n-1) + fib(n-2);
}
```

---

# 探索

---

## 全探索

全探索とは、しらみつぶしに全ての可能性を調べること

- 深さ優先探索
- 幅優先探索

![](https://i.imgur.com/4NELPBA.png)

---

## 深さ優先探索(DFS)

> a1 , a2 ... anの中から幾つか選び、その和をちょうどkにすることが出来るかを判定しなさい。
> 1 ≦ n ≦ 20
> -10^8 ≦ ai ≦ 10^8
> -10^8 ≦ k ≦ 10^8

---

## 深さ優先探索(DFS)

```
n=4
a={1,2,4,7}
k=13
→
Yes
```

---

## 深さ優先探索(DFS)

> 大きさがN × M の庭があります。そこに雨が振り水たまりが出来ました。水たまりは八近傍で近接している場合につながってるとみなします。全部でいくつの水たまりがあるでしょうか？

---

## 深さ優先探索(DFS)

```
N = 10, M = 7

...W...WW.
..W.W..WW.
...W...W..
...W...W..
.......W..
..W.....W.
..W....W..


→　3
```

---

## 深さ優先探索

ある状態からはじめ、遷移できなくなるまで状態を進め、遷移できなくなったら1つ前の状態に戻るを繰り返す。

---


## 幅優先探索(BFS)


> 大きさがM×Nの迷路が与えられる。
> 迷路は壁と通路から出来ており、1ターンに隣接する上下左右４つの通路へ移動できる。
> スタートからゴールまでの最小のターン数を求めよ。

---

## 幅優先探索(BFS)

```
N = 10, M = 10

#S######.#
......#..#
.#.##.##.#
.#........
##.##.####
....#....#
.#######.#
....#.....
.####.###.
....#...G#

→ 22

```

他

[深さ優先探索による塗りつぶし](http://www.slideshare.net/chokudai/dfs-49066641)


---

## 二分探索

> 長さnの単調非現象な数列a0...an-1(ソートされている)と数kが与えられる。ai ≧ kとなるような最小のiを求めなさい。存在しない場合はnを出力しなさい。

```
n = 5
a = {2,3,3,5,6}
k = 3
```

---

## 二分探索

- n/2番目の値を見る
- a[n/2]≧kなら解はn/2以下
- a[n/2]＜kなら解はn/2より大きい

これを繰り返す。

---

## 二分探索

![](http://officemiyajima.com/swfu/d/binary_search.png)

---

# DP(動的計画法)

---


## DP(動的計画法)

基礎でやったフィボナッチ数のプログラムはn=40程度までしか計算できない

![](https://i.imgur.com/ScstbXP.png)

何度も同じ引数でfib関数を実行していることがわかる。



---

## DP(動的計画法)

改良版

```
int fib(unsigned int n){
	vector<int> arr(n+1);
	arr[0] = 0;
	arr[1] = 1;
	for(int i=2; i <= n; ++i){
		arr[i] = arr[i-1] + arr[i-2];
	}	
}

```
O(n)の線形アルゴリズム
n = 10 ^ 7くらいまで対応可能(n=47くらいでintがオーバーフロー)

---

## DP(動的計画法)

> ナップサック問題
> 重さと価値がWi,Viであるようなn個の品物がある。
> これらの品物から、重さの総和がWを超えないように選んだときの、価値の総和の最大値を求めよ。

![](https://upload.wikimedia.org/wikipedia/commons/thumb/f/fd/Knapsack.svg/220px-Knapsack.svg.png)

---

### ナップサック問題


```
n = 4
(w,v) = {{2,3},{1,2},{3,4},{2,2}}
W = 5

→ 7(0,1,3番の品物を選ぶ)

```

---

### ナップサック問題

ナイーブな方法

- それぞれの品物について、入れるか入れないかの二通りを調べる
- 体積の合計がWを超えない方の入れ物の中で、価値が最大になる方を選ぶ

---

### ナップサック問題

```
int n,W;
int w[MAX_N],v[MAX_N];

int rec(int i,int j){
	int res;
	if(i == n){
		res = 0;
	}else if(j < w[i]){
		res = rec ( i+1 , j);
	}else{
		res = max ( rec( i + 1 , j ),rec (i + 1,j-w[i]) + v[i]);
	}
	return res;
}
int main(){
	input();
	cout << rec ( 0 , W);
}
```

n個の品物に対してO(2^n)のアルゴリズム
n = 1000だとだいたい 3.4×10^285 年 かかる

---

## ここでDP

![](http://image.itmedia.co.jp/enterprise/articles/1005/15/tnalgfig5.gif)

同じ引数のものが複数あるが、同じ引数であれば返り値もおなじになるため、記憶しておけば計算する必要はなくなる。


→　改良できる。


---

- ナップサック問題であればいつでもDPを使うわけではない。
- 条件が
	
	1 ≦ n ≦ 20 , 1 ≦ P ≦ 1,000,000,000
	
	1 ≦ Vi ≦ 1,000,000,000　1≦C≦1,000,000,000
	のとき、動的計画法では解けないがナイーブな方法を使えば解ける。
- 条件をよく読んで使い分ける。
	


---


# データ構造

データ構造とはデータの持ち方のこと。
データをどのように持つかによって効率的な操作方法が変わってくる。

---

## データ構造

### 木・二分木

- ヒープ

プライオリティキュー（次のことが出来るデータ構造）

- 数を追加する
- 最小の数値を取り出す（値を取得し、削除する）

これを二分木を用いて効率的に実現するのがヒープ。

---

### ヒープ

![](https://upload.wikimedia.org/wikipedia/commons/6/60/Binary_heap_indexing.png)

- 必ず子の数字は親の数字よりも大きい。
- 木は上から下へ、左から右へ順にノードが詰まっている

---

### ヒープ

実装例

二分木をポインタなどを用いて表現するのではなく、ノードに番号をつけて配列で持つ。


- 左の子は、自分の番号×2+1
- 右の子は、自分の番号×2+2


```
int heap[MAX_N],sz=0;
void push(int x){
	int i = sz++;
	while(i>0){
		int p = (i-1)/2;
		if(heap[p] <= x) break;
		heap[i] = heap[p];
		i = p;
	}
	heap[i] = x;
}
void pop(){
	int ret=heap[0];
	int x = heap[--sz];
	int i=0;
	while(i*2+1 < sz){
		int a=i*2 + 1,b = i*2+2;
		if(b<sz && heap[b] < heap[a])a=b;
		if(heap[a] >= x) break;
		heap[i] = heap[a];
		i=a;
	}
	heap[i] = x;
	return ret;
}
```

--- 

## ヒープ

stlにあるものを使う。

→ priority_queue

```
#include <queue>
```

---

## ２分探索木(Binary search tree)

次のことが出来るデータ構造

- 数値を追加する。
- ある数値が含まれているか調べる。
- ある数値を削除する。

実装によって他にもさまざまな操作が行える、応用力の高いデータ構造。


---

## ２分探索木

![](https://upload.wikimedia.org/wikipedia/commons/thumb/d/da/Binary_search_tree.svg/300px-Binary_search_tree.svg.png)

---

## ２分探索木


- すべてのノードについて、左の子以下の数は自分の数より全て小さく、右の子以下の数はすべて大きくなるように管理する。

- 計算量は木の深さに比例した時間( 要素数nに対して O(log n)) がかかる。

- → stlにsetやmapというコンテナが含まれている。
	- setは集合を２分探索木で管理するコンテナ
	- mapはキーとそれに対応する値を管理するコンテナ
	

---

## ２分探索木

### 平衡二分木

木の深さが偏らないように、回転処理などを使って常に平衡を保つような二分木

- B木(ハードディスクなどブロック単位のランダムアクセスが可能なものに適した構造)
	- B+木・B*木（DBMSなどに使われるB木の改良・亜種）
- 2-3木
- 平衡２分探索木(平衡木であり、同時に二分探索木でもある木)
	- AA木(赤黒木と性能は同等だがアルゴリズムが単純)
	- 赤黒木(連想配列の実装に用いられる)
	- AVL木

---

## Union-Find木

グループ分けを管理するデータ構造。次のことが効率的に行える。

- 要素aと要素bが同じグループに属するかを調べる。
- 要素aと要素bのグループを併合する。

※グループを併合できても分割は出来ない。


---

## Union-Find木

[AtCoder Union Find](http://www.slideshare.net/chokudai/union-find-49066733)


----

## Union-Find木

> N匹の動物がいて、1,2...Nと番号が付けられている。
> 動物はすべて３つの種類A,B,Cのどれか。
> AはBを食べ、BはCを食べ、CはAを食べる。
> 次の二種類の情報が順番にk個与えられる。
> - タイプ１：xとyは同じ種類です。
> - タイプ２：xはyを食べます。
>
> これらはすべて正しいとはかぎらない。以前に与えられた情報と矛盾する情報や、x,yが正しい番号(1,2,..N)出ないような正しくない情報が与えられる可能性がある。
> K個の情報からそのような情報を出力して下さい。
> また、そのような情報は捨てると考えます。

---

## Union-Find木

```
N = 100 , K = 7

- タイプ 1 , x = 101 , y = 1
- タイプ 2 , x = 1 , y = 2
- タイプ 1 , x = 2 , y = 3
- タイプ 2 , x = 3 , y = 3
- タイプ 1 , x = 1 , y = 3
- タイプ 2 , x = 3 , y = 1
- タイプ 1 , x = 5 , y = 5

→　3(1つ目、４つ目、５つ目がおかしな情報)

